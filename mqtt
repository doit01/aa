ThingsBoard ä¸­çš„ â€ŒAppActorâ€Œ æ˜¯æ•´ä¸ª Actor ç³»ç»Ÿçš„æ ¸å¿ƒè°ƒåº¦æ¢çº½ï¼Œæ‰¿æ‹…ç§Ÿæˆ·ç®¡ç†ã€æ¶ˆæ¯è·¯ç”±å’Œèµ„æºåè°ƒçš„å…³é”®èŒè´£ï¼Œå…·ä½“ä½œç”¨å¦‚ä¸‹ï¼š

ğŸ”§ â€Œæ ¸å¿ƒåŠŸèƒ½â€Œ

ç§Ÿæˆ· Actor ç®¡ç†ä¸­æ¢â€Œ

ä½œä¸ºç³»ç»Ÿå¯åŠ¨æ—¶åˆ›å»ºçš„â€Œå”¯ä¸€é¡¶çº§å¸¸é©» Actorâ€Œï¼Œè´Ÿè´£åŠ¨æ€åˆ›å»ºã€ç»´æŠ¤å’Œé”€æ¯æ‰€æœ‰ç§Ÿæˆ·ï¼ˆTenantï¼‰å¯¹åº”çš„ TenantActor å®ä¾‹ ã€‚
æ¯ä¸ªç§Ÿæˆ·é¦–æ¬¡æ¥å…¥è®¾å¤‡æˆ–è§¦å‘è§„åˆ™æ—¶ï¼ŒAppActor ä¼šæŒ‰éœ€åˆå§‹åŒ–å…¶ä¸“å±çš„ TenantActor ã€‚

å…¨å±€æ¶ˆæ¯è·¯ç”±ç½‘å…³â€Œ

æ‰€æœ‰å¤–éƒ¨ä¼ å…¥çš„æ¶ˆæ¯ï¼ˆå¦‚è®¾å¤‡æ•°æ®ã€è§„åˆ™å¼•æ“äº‹ä»¶ï¼‰é¦–å…ˆç”± AppActor æ¥æ”¶ï¼Œå†æ ¹æ®â€Œç§Ÿæˆ· IDâ€Œ ç²¾å‡†è·¯ç”±è‡³å¯¹åº”çš„ TenantActor é‚®ç®± ã€‚
ç¤ºä¾‹ï¼šè®¾å¤‡ä¸ŠæŠ¥æ•°æ® â†’ AppActor è¯†åˆ«ç§Ÿæˆ· â†’ è½¬å‘è‡³ç›®æ ‡ TenantActor ã€‚

èµ„æºç”Ÿå‘½å‘¨æœŸç®¡æ§â€Œ

ç›‘æ§ç§Ÿæˆ· Actor çš„æ´»åŠ¨çŠ¶æ€ï¼Œåœ¨ç§Ÿæˆ·é•¿æ—¶é—´æ— è¯·æ±‚æ—¶â€Œè‡ªåŠ¨å›æ”¶â€Œé—²ç½®çš„ TenantActor ä»¥é‡Šæ”¾å†…å­˜èµ„æºï¼ˆæƒ°æ€§åœæ­¢æœºåˆ¶ï¼‰ã€‚
ç¡®ä¿é«˜å¹¶å‘åœºæ™¯ä¸‹ä»…æ´»è·ƒç§Ÿæˆ·å ç”¨è¿è¡Œæ—¶èµ„æº ã€‚
âš™ï¸ â€Œåä½œæµç¨‹ç¤ºä¾‹â€Œ
mermaid
Copy Code
sequenceDiagram
    participant Device as è®¾å¤‡ç«¯
    participant AppActor
    participant TenantActor
    participant RuleChainActor
    
    Device ->> AppActor: å‘é€æ•°æ®(å«ç§Ÿæˆ·ID)
    AppActor ->> TenantActor: æŒ‰ç§Ÿæˆ·IDè·¯ç”±æ¶ˆæ¯
    TenantActor ->> RuleChainActor: è°ƒç”¨è§„åˆ™é“¾å¤„ç†
    RuleChainActor -->> Device: è¿”å›å“åº”(å¦‚RPCæŒ‡ä»¤)


ğŸ’¡ â€Œè®¾è®¡ä¼˜åŠ¿â€Œï¼š

éš”ç¦»æ€§â€Œï¼šç§Ÿæˆ·é—´ Actor å®Œå…¨ç‹¬ç«‹ï¼Œæ•…éšœäº’ä¸å½±å“ ï¼›
å¼¹æ€§ä¼¸ç¼©â€Œï¼šåŠ¨æ€ç®¡ç†ç§Ÿæˆ· Actorï¼Œæ”¯æ’‘ç™¾ä¸‡çº§è®¾å¤‡æ¥å…¥ ï¼›
ç®€åŒ–è¿ç»´â€Œï¼šç»Ÿä¸€å…¥å£é™ä½åˆ†å¸ƒå¼ç³»ç»Ÿå¤æ‚åº¦ ã€‚


è¦é€‰æ‹©é€‚åˆå®æ—¶åœºæ™¯çš„MQTT QoSç­‰çº§ï¼Œéœ€å¹³è¡¡æ¶ˆæ¯å¯é æ€§ã€ä¼ è¾“å»¶è¿ŸåŠç½‘ç»œæ¡ä»¶ï¼Œæ ¸å¿ƒå†³ç­–é€»è¾‘å¦‚ä¸‹ï¼š

ğŸ“Š â€ŒQoSç­‰çº§ç‰¹æ€§å¯¹æ¯”â€Œ
QoSç­‰çº§â€Œ	ä¼ è¾“æœºåˆ¶	å®æ—¶æ€§	å¯é æ€§	é€‚ç”¨åœºæ™¯æ¡ˆä¾‹
QoS 0â€Œ	æœ€å¤šä¸€æ¬¡ï¼ˆä¸é‡ä¼ ï¼‰	â­â­â­â­	â­	é«˜é¢‘ä¼ æ„Ÿå™¨ä¸ŠæŠ¥ï¼ˆå¦‚æ¸©åº¦æ³¢åŠ¨ï¼‰
QoS 1â€Œ	è‡³å°‘ä¸€æ¬¡ï¼ˆè‡ªåŠ¨é‡ä¼ ï¼‰	â­â­â­	â­â­â­	å®æ—¶æ§åˆ¶æŒ‡ä»¤ï¼ˆå¦‚å¼€å…³ç¯ï¼‰
QoS 2â€Œ	æ°å¥½ä¸€æ¬¡ï¼ˆå››æ¬¡æ¡æ‰‹ï¼‰	â­	â­â­â­â­â­	é‡‘èäº¤æ˜“ã€åŒ»ç–—å‘Šè­¦
ğŸ” â€Œé€‰æ‹©ç­–ç•¥â€Œ
1ï¸âƒ£ â€Œä¼˜å…ˆQoS 0çš„åœºæ™¯â€Œ
å¼ºå®æ—¶æ€§è¦æ±‚â€Œï¼šå…è®¸å°‘é‡æ•°æ®ä¸¢å¤±ï¼Œå¦‚é«˜é¢‘ä¼ æ„Ÿå™¨æ•°æ®ï¼ˆ>10Hzï¼‰æˆ–å®æ—¶è§†é¢‘æµç›‘æ§ã€‚
ç½‘ç»œç¨³å®šç¯å¢ƒâ€Œï¼šä¸“ç½‘æˆ–ä½ä¸¢åŒ…ç‡åœºæ™¯ï¼Œé¿å…é‡ä¼ å¼€é”€ã€‚
2ï¸âƒ£ â€Œé€‰æ‹©QoS 1çš„åœºæ™¯â€Œ
éœ€ç¡®è®¤é€è¾¾â€Œï¼šæ§åˆ¶æŒ‡ä»¤ï¼ˆå¦‚è®¾å¤‡å¯åœï¼‰ã€çŠ¶æ€æ›´æ–°ï¼ˆå¦‚é—¨é”å¼€å…³ï¼‰ã€‚
å¼±ç½‘å®¹å¿é‡å¤â€Œï¼šæ¥å—å°‘é‡æ¶ˆæ¯é‡å¤ï¼ˆå®¢æˆ·ç«¯éœ€åšå¹‚ç­‰å¤„ç†ï¼‰ã€‚
3ï¸âƒ£ â€Œæ…ç”¨QoS 2çš„åœºæ™¯â€Œ
ä¸¥æ ¼é˜²é‡éœ€æ±‚â€Œï¼šæ”¯ä»˜ç¡®è®¤ã€è¯å“å‰‚é‡æŒ‡ä»¤ç­‰å…³é”®æ“ä½œã€‚
å»¶è¿Ÿä¸æ•æ„Ÿâ€Œï¼šå¯æ¥å—é¢å¤–200ms+æ¡æ‰‹å»¶è¿Ÿï¼ˆå¯¹æ¯”QoS 1ï¼‰ã€‚
âš ï¸ â€Œæ³¨æ„äº‹é¡¹â€Œ
æœåŠ¡ç«¯é™çº§æœºåˆ¶â€Œ
Brokerå®é™…æŒ‰â€Œå‘å¸ƒä¸è®¢é˜…ç«¯QoSçš„æœ€ä½ç­‰çº§â€Œä¼ è¾“ï¼ˆå¦‚Pubç«¯QoS 2 + Subç«¯QoS 1 â†’ å®é™…QoS 1ï¼‰ã€‚
å®¢æˆ·ç«¯æ€§èƒ½ä¼˜åŒ–â€Œ
QoS 1/2åœºæ™¯å¯ç”¨å¼‚æ­¥å›è°ƒï¼Œé¿å…é˜»å¡æ¶ˆæ¯å¤„ç†çº¿ç¨‹ã€‚
è®¾ç½®åˆç†å¿ƒè·³é—´éš”ï¼ˆå¦‚10-30ç§’ï¼‰ï¼Œå‡å°‘å‡æ€§æ–­è¿ã€‚
ç½‘ç»œé€‚åº”æ€§â€Œ
é«˜æŠ–åŠ¨ç½‘ç»œå»ºè®®QoS 1è€ŒéQoS 2ï¼Œé¿å…æ¡æ‰‹å¤±è´¥ç´¯ç§¯å»¶è¿Ÿã€‚

ğŸ’¡ â€Œå†³ç­–æ ‘ç¤ºä¾‹â€Œï¼š

mermaid
Copy Code
graph TD
  A[èƒ½å¦å®¹å¿æ¶ˆæ¯ä¸¢å¤±ï¼Ÿ] -- æ˜¯ --> B[é€‰QoS 0]
  A -- å¦ --> C[èƒ½å¦å®¹å¿æ¶ˆæ¯é‡å¤ï¼Ÿ]
  C -- æ˜¯ --> D[é€‰QoS 1]
  C -- å¦ --> E[é€‰QoS 2]

æ•°æ®æµè½¬å¤§æ¦‚æµç¨‹

æ‰¾åˆ°MqttTransportServiceç±»==ã€‹é€šè¿‡@PostConstructæ³¨è§£åœ¨é¡¹ç›®å¯åŠ¨åè¿›å…¥init()æ–¹æ³•
==ã€‹é‡Œé¢ç»‘å®šäº†MqttTransportServerInitializerç±»å³mqttæœåŠ¡åˆå§‹åŒ–
==ã€‹MqttTransportServerInitializerç±»ç»§æ‰¿ChannelInitializerç±»é‡å†™äº†initChannelæ–¹æ³•
==ã€‹initChannelæ–¹æ³•é‡Œç»‘å®šäº†MqttTransportHandler
==ã€‹è¿›å…¥MqttTransportHandlerçš„channelReadæ–¹æ³•ï¼ŒéªŒè¯æ¶ˆæ¯ç±»å‹ä¸ºmqttæ—¶è½¬å…¥processMqttMsgæ–¹æ³•
==ã€‹processMqttMsgé‡Œè¿›è¡Œåˆ¤æ–­ï¼šæ¶ˆæ¯ç±»å‹ä¸ºè¿æ¥æ—¶è½¬å…¥processConnectï¼Œè®¾å¤‡sessionä¸ºä¸´æ—¶çš„è½¬å…¥processProvisionSessionMsg
å¦åˆ™è½¬å…¥enqueueRegularSessionMsgæ–¹æ³•ï¼Œè¿™é‡Œå…ˆæ¢è®¨è½¬å…¥enqueueRegularSessionMsg
==ã€‹è½¬å…¥enqueueRegularSessionMsgåè°ƒç”¨processMsgQueueå°†æ¶ˆæ¯æŠ•é€’åˆ°é˜Ÿåˆ—
==ã€‹è·Ÿè¿›å»å‘ç°é‡Œé¢è°ƒç”¨äº†processRegularSessionMsgæ–¹æ³•
==ã€‹processRegularSessionMsgé‡Œæ ¹æ®æ¶ˆæ¯çš„ç±»å‹è¿›è¡Œè½¬å‘ï¼Œæ¯”å¦‚ï¼šå‘å¸ƒï¼Œè®¢é˜…ï¼Œå–æ¶ˆè®¢é˜…ï¼Œå–æ¶ˆè¿æ¥ç­‰ç­‰
==ã€‹è·Ÿè¿›PUBLISHï¼Œè½¬å…¥processPublishæ–¹æ³•
==ã€‹è½¬å…¥processDevicePublishï¼Œè¿›å…¥å‘ç°è¿™é‡Œæ ¹æ®æ¶ˆæ¯çš„ä¸»é¢˜è¿›è¡Œè½¬å‘ï¼Œè¿™é‡Œé€‰æ‹©isDeviceTelemetryTopicå¯¹åº”çš„transportService.processæ¥å£å®ç°
==ã€‹å‘ç°è¿™é‡Œå¯¹æ¶ˆæ¯å°è£…äº†ä¸€ä¸‹ä¹‹åè½¬å…¥sendToRuleEngineï¼Œå°†æ¶ˆæ¯å‘é€åˆ°è§„åˆ™é“¾
ã€‹ç»§ç»­è·Ÿè¿›è¿›å…¥sendToRuleEngineï¼Œå‘ç°è°ƒç”¨ruleEngineMsgProducer.sendï¼Œå³å°†æ¶ˆæ¯é€šè¿‡ç”Ÿäº§è€…å‘é€åˆ°é˜Ÿåˆ—
è¿™é‡Œå¯¹åº”å¤šä¸ªå®ç°ï¼Œä¾‹å¦‚ï¼šinMemoryï¼ŒKafkaï¼ŒRabbitMQç­‰ç­‰ï¼Œé»˜è®¤å‘é€åˆ°inMemoryå†…å­˜
ã€‹æœ‰ç”Ÿäº§è€…é‚£è‚¯å®šæœ‰æ¶ˆè´¹è€…ï¼Œæˆ‘ä»¬æ‰¾åˆ°DefaultTbRuleEngineConsumerServiceæ ¸å¿ƒæ¶ˆè´¹è€…
ã€‹æ‰¾åˆ°launchMainConsumersæ–¹æ³•ã€‹launchConsumerã€‹consumerLoop
ã€‹å‘ç°consumerLoopæ˜¯ä¸ªå¾ªç¯ï¼Œå°†æ¶ˆæ¯å–å‡ºæ¥æ¶ˆè´¹ï¼Œè½¬submitMessageæ–¹æ³•
ã€‹ç„¶åè½¬å…¥forwardToRuleEngineActorã€‹è°ƒç”¨actorContext.tellï¼Œè¿™é‡Œå¼€å§‹å°±æ˜¯Actoræ¨¡å‹æµè½¬äº†ï¼Œä¸æ¸…æ¥šçš„å¯ä»¥å»ç™¾åº¦æœç´¢ä¸€ä¸‹
ã€‹é¦–å…ˆè°ƒç”¨appActor.tellé€šè¿‡æ ¹appActorè°ƒç”¨tellæ–¹æ³•è½¬å…¥enqueueæ–¹æ³•ï¼Œé‡Œé¢å¯¹æ¶ˆæ¯è¿›è¡Œäº†åˆ†ç±»ï¼Œåˆ†ä¸ºé«˜ä¼˜å…ˆçº§å’Œæ­£å¸¸æ¶ˆæ¯é˜Ÿåˆ—
è¿˜æœ‰initActor()æ–¹æ³•åˆ›å»ºä¸€ç³»åˆ—actorï¼Œå¤§æ¦‚æµç¨‹ï¼šAppActorã€‹TenantActorã€‹RuleChainActorã€‹RuleNodeActor,æˆ‘ä»¬å…ˆè½¬å…¥tryProcessQueueæ–¹æ³•
==>ç„¶åå‘ç°è°ƒç”¨äº†processMailboxï¼Œå‘ç°è¿™é‡Œæ˜¯å°†ä¹‹å‰åˆ†ç±»çš„æ¶ˆæ¯ä¾æ¬¡å–å‡ºæ¥ç„¶åè°ƒç”¨actor.process(msg)æ–¹æ³•ä¾æ¬¡å‘ä¸‹æµè½¬å¤„ç†æ¶ˆæ¯

ã€‹ContextAwareActorã€‹process==ã€‹doProcess==ã€‹â€¦
how to make a mqtt server?
0 use netty
1 create MqttTransportService @Service("MqttTransportService")
     @PostConstruct
    public void init() throws Exception {
        log.info("Setting resource leak detector level to {}", leakDetectorLevel);
        ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.valueOf(leakDetectorLevel.toUpperCase()));

        log.info("Starting MQTT transport...");
        bossGroup = new NioEventLoopGroup(bossGroupThreadCount);
        workerGroup = new NioEventLoopGroup(workerGroupThreadCount);
        ServerBootstrap b = new ServerBootstrap();
        b.group(bossGroup, workerGroup)
                .channel(NioServerSocketChannel.class)
                .childHandler(new MqttTransportServerInitializer(context, false))
                .childOption(ChannelOption.SO_KEEPALIVE, keepAlive);

        serverChannel = b.bind(host, port).sync().channel();
        if (sslEnabled) {
            b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new MqttTransportServerInitializer(context, true))
                    .childOption(ChannelOption.SO_KEEPALIVE, keepAlive);
            sslServerChannel = b.bind(sslHost, sslPort).sync().channel();
        }
        log.info("Mqtt transport started!");
    }

application jar depending on transport mqtt service.
       <groupId>org.thingsboard.common.transport</groupId>
    <artifactId>mqtt</artifactId>


    2
    MqttTransportServerInitializer initChannel()
     ChannelPipeline pipeline = ch.pipeline();
       pipeline.addLast("decoder", new MqttDecoder(context.getMaxPayloadSize()));
        pipeline.addLast("encoder", MqttEncoder.INSTANCE);
MqttTransportHandler handler = new MqttTransportHandler(context, sslHandler);

        pipeline.addLast(handler);

3 MqttTransportHandler
 public void channelRead(ChannelHandlerContext ctx, Object msg) {
